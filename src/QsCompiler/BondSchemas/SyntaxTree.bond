namespace Microsoft.Quantum.QsCompiler.BondSchemas;

/*
    
*/
enum QsBindingKind {
    ImmutableBinding,
    MutableBinding
}

/*
    
*/
enum QsSpecializationKind {
    QsBody,
    QsAdjoint,
    QsControlled,
    QsControlledAdjoint
}

/*
    
*/
enum QsCallableKind {
    Operation,
    Function,
    TypeConstructor
}

/*
    
*/
enum QsQubitScopeKind {
    Allocate,
    Borrow
}

/*
    
*/
struct QsQualifiedName
{
    5: required string Namespace;

    10: required string Name;
}

/*
    
*/
enum SymbolTupleKind {
    InvalidItem,
    VariableName,
    VariableNameTuple,
    DiscardedItem
}

/*
    
*/
struct SymbolTuple
{
    5: required SymbolTupleKind Kind = InvalidItem;

    // TODO: Check what type might be useful for an 'InvalidItem' kind. Use string in the meantime.
    10: nullable<string> InvalidItem = nothing;

    15: nullable<string> VariableName = nothing;

    20: nullable<vector<SymbolTuple>> VariableNameTuple = nothing;

    // TODO: The real type of this is an ITuple object but have a placeholder in the meantime.
    25: nullable<list<string>> DiscardedItem = nothing;
}

/*
    
*/
struct QsBinding
{
    5: required QsBindingKind Kind = ImmutableBinding;

    10: required SymbolTuple Lhs;

    // TODO: The real type of this is variable (Generic 'T) but have a placeholder in the meantime.
    15: required string Rhs;
}

/*
    
*/
enum IdentifierKind {
    LocalVariable,
    GlobalCallable,
    InvalidIdentifier
}

/*
    
*/
struct Identifier
{
    5: required IdentifierKind Kind = LocalVariable;

    10: nullable<string> LocalVariable = nothing;

    15: nullable<QsQualifiedName> GlobalCallable = nothing;

    // TODO: Check what type moigh be useful for an 'InvalidIdentifier' kind. Use string in the meantime.
    20: nullable<string> InvalidIdentifier = nothing;
}

/*
    

    N.B. This does not exist in the F# data structures but it is required since tuples are not supported.
*/
struct QsLocationOffset
{
    5: required int32 Line;

    10: required int32 Character;
}

/*
    
*/
struct QsPositionInfo
{
    5: required int32 Line;

    10: required int32 Column;
}

/*
    

    N.B. All uses of this data structure should be nullable.
*/
struct QsRangeInfo
{
    // TODO: The name left might not be correct for all cases.
    5: required QsPositionInfo Left;

    // TODO: The name right might not be correct for all cases.
    10: required QsPositionInfo Right;
}

/*
    
*/
struct QsLocation
{
    5: required QsLocationOffset Offset;

    10: nullable<QsRangeInfo> Range = nothing;
}

/*
    
*/
struct QsTypeParameter
{
    5: required QsQualifiedName Origin;

    10: required string TypeName;

    15: nullable<QsRangeInfo> Range = nothing;
}

/*
    
*/
struct UserDefinedType
{
    5: required string Namespace;

    10: required string Name;

    15: nullable<QsRangeInfo> Range = nothing;
}

/*
    
*/
enum CharacteristicsKind {
    EmptySet,
    SimpleSet,
    Union,
    Intersection,
    InvalidSetExpr
}

/*
    
*/
struct ResolvedCharacteristics
{
    5: required CharacteristicsKind Kind = EmptySet;

    // TODO: Implement per 'Kind' fields.
}

/*
    
*/
struct InferredCallableInformation
{
    5: required bool IsSelfAdjoint;

    10: required bool IsIntrinsic;
}

/*
    
*/
struct CallableInformation
{
    5: required ResolvedCharacteristics Characteristics;

    10: required InferredCallableInformation InferredInformation;
}

/*
    
*/
enum QsTypeKind {
    UnitType,
    Int,
    BigInt,
    Double,
    Bool,
    String,
    Qubit,
    Result,
    Pauli,
    Range,
    ArrayType,
    TupleType,
    UserDefinedType,
    TypeParameter,
    Operation,
    Function,
    MissingType,
    InvalidType
}

/*
    
*/
struct ResolvedType
{
    5: required QsTypeKind Kind = InvalidType;

    // TODO: Add a field per 'Kind'.
}

/*
    
*/
struct InferredExpressionInformation
{
    5: required bool IsMutable;

    10: required bool HasLocalQuantumDependency;
}

/*
    
*/
enum QsExpressionKind {
    UnitValue,
    Identifier,
    ValueTuple,
    IntLiteral,
    BigIntLiteral,
    DoubleLiteral,
    BoolLiteral,
    StringLiteral,
    ResultLiteral,
    PauliLiteral,
    RangeLiteral,
    NewArray,
    ValueArray,
    ArrayItem,
    NamedItem,
    NEG,
    NOT,
    BNOT,
    ADD,
    SUB,
    MUL,
    DIV,
    MOD,
    POW,
    EQ,
    NEQ,
    LT,
    LTE,
    GT,
    GTE,
    AND,
    OR,
    BOR,
    BAND,
    BXOR,
    LSHIFT,
    RSHIFT,
    CONDITIONAL,
    CopyAndUpdate,
    UnwrapApplication,
    AdjointApplication,
    ControlledApplication,
    CallLikeExpression,
    MissingExpr,
    InvalidExpr
}

/*
    
*/
struct TypedExpression
{
    5: required QsExpressionKind Kind = InvalidExpr;

    // TODO: Finish implementing this data structure.
}


/*
    
*/
struct QsNamespace
{
    5: required string Name;

    // TODO: Finish implementing this data structure.
}

/*
    
*/
struct QsCompilation
{
    5: required vector<QsNamespace> Namespaces;

    // TODO: Finish implementing this data structure.
}
